import{getOwnReflectMetadata as e,setReflectMetadata as t,updateOwnReflectMetadata as n}from"@inversifyjs/reflect-metadata-utils";import{getBaseType as i}from"@inversifyjs/prototype-utils";import{stringifyServiceIdentifier as o,LazyServiceIdentifier as r,isPromise as a}from"@inversifyjs/common";const s="@inversifyjs/container/bindingId";function c(){const i=e(Object,s)??0;return i===Number.MAX_SAFE_INTEGER?t(Object,s,Number.MIN_SAFE_INTEGER):n(Object,s,(()=>i),(e=>e+1)),i}const u={Request:"Request",Singleton:"Singleton",Transient:"Transient"},d={ConstantValue:"ConstantValue",DynamicValue:"DynamicValue",Factory:"Factory",Instance:"Instance",Provider:"Provider",ResolvedValue:"ResolvedValue",ServiceRedirection:"ServiceRedirection"};function*l(...e){for(const t of e)yield*t}class p{#e;#t;#n;constructor(e){this.#e=new Map,this.#t={};for(const t of Reflect.ownKeys(e))this.#t[t]=new Map;this.#n=e}add(e,t){this.#i(e).push(t);for(const n of Reflect.ownKeys(t))this.#o(n,t[n]).push(e)}clone(){const e=Reflect.ownKeys(this.#n),t=new p(this.#n);this.#r(this.#e,t.#e);for(const n of e)this.#r(this.#t[n],t.#t[n]);return t}get(e,t){return this.#t[e].get(t)}getAllKeys(e){return this.#t[e].keys()}removeByRelation(e,t){const n=this.get(e,t);if(void 0===n)return;const i=new Set(n);for(const n of i){const i=this.#e.get(n);if(void 0===i)throw new Error("Expecting model relation, none found");for(const o of i)o[e]===t&&this.#a(n,o);this.#e.delete(n)}}#i(e){let t=this.#e.get(e);return void 0===t&&(t=[],this.#e.set(e,t)),t}#o(e,t){let n=this.#t[e].get(t);return void 0===n&&(n=[],this.#t[e].set(t,n)),n}#r(e,t){for(const[n,i]of e)t.set(n,[...i])}#a(e,t){for(const n of Reflect.ownKeys(t))this.#s(e,n,t[n])}#s(e,t,n){const i=this.#t[t].get(n);if(void 0!==i){const o=i.indexOf(e);-1!==o&&i.splice(o,1),0===i.length&&this.#t[t].delete(n)}}}var f,g,m;!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(f||(f={}));class h{#c;#u;constructor(e,t){this.#c=t??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new h(e)}add(e,t){this.#c.add(e,t)}clone(){return new h(this.#u,this.#c.clone())}get(e){const t=[],n=this.#c.get(f.serviceId,e);void 0!==n&&t.push(n);const i=this.#u?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return l(...t)}removeAllByModuleId(e){this.#c.removeByRelation(f.moduleId,e)}removeAllByServiceId(e){this.#c.removeByRelation(f.serviceId,e)}}!function(e){e.id="id",e.moduleId="moduleId",e.serviceId="serviceId"}(g||(g={}));class v{#d;#u;constructor(e,t){this.#d=t??new p({id:{isOptional:!1},moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new v(e)}clone(){return new v(this.#u,this.#d.clone())}get(e){return this.getNonParentBindings(e)??this.#u?.get(e)}getById(e){return this.#d.get(g.id,e)??this.#u?.getById(e)}getByModuleId(e){return this.#d.get(g.moduleId,e)??this.#u?.getByModuleId(e)}getNonParentBindings(e){return this.#d.get(g.serviceId,e)}getNonParentBoundServices(){return this.#d.getAllKeys(g.serviceId)}removeById(e){this.#d.removeByRelation(g.id,e)}removeAllByModuleId(e){this.#d.removeByRelation(g.moduleId,e)}removeAllByServiceId(e){this.#d.removeByRelation(g.serviceId,e)}set(e){const t={[g.id]:e.id,[g.serviceId]:e.serviceIdentifier};void 0!==e.moduleId&&(t[g.moduleId]=e.moduleId),this.#d.add(e,t)}}!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(m||(m={}));class y{#l;#u;constructor(e,t){this.#l=t??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new y(e)}add(e,t){this.#l.add(e,t)}clone(){return new y(this.#u,this.#l.clone())}get(e){const t=[],n=this.#l.get(m.serviceId,e);void 0!==n&&t.push(n);const i=this.#u?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return l(...t)}removeAllByModuleId(e){this.#l.removeByRelation(m.moduleId,e)}removeAllByServiceId(e){this.#l.removeByRelation(m.serviceId,e)}}function M(e,t,n){const i=Array.isArray(e)?e:[e];if(void 0!==n)if("number"!=typeof n)Reflect.decorate(i,t.prototype,n);else for(const e of i)e(t,void 0,n);else Reflect.decorate(i,t)}const I="@inversifyjs/core/classMetadataReflectKey";function w(){return{constructorArguments:[],lifecycle:{postConstructMethodName:void 0,preDestroyMethodName:void 0},properties:new Map,scope:void 0}}const b="@inversifyjs/core/pendingClassMetadataCountReflectKey";const j=Symbol.for("@inversifyjs/core/InversifyCoreError");class T extends Error{[j];kind;constructor(e,t,n){super(t,n),this[j]=!0,this.kind=e}static is(e){return"object"==typeof e&&null!==e&&!0===e[j]}static isErrorOfKind(e,t){return T.is(e)&&e.kind===t}}var S,A,C;function $(t){const n=e(t,I)??w();if(!function(t){const n=e(t,b);return void 0!==n&&0!==n}(t))return function(e,t){const n=[];if(t.length<e.length)throw new T(S.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}". "${e.name}" constructor requires at least ${e.length.toString()} arguments, found ${t.length.toString()} instead.\nAre you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);for(let e=0;e<t.length;++e)void 0===t[e]&&n.push(e);if(n.length>0)throw new T(S.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}" at constructor indexes "${n.join('", "')}".\n\nAre you using @inject, @multiInject or @unmanaged decorators at those indexes?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`)}(t,n.constructorArguments),n;!function(e,t){const n=[];for(let i=0;i<t.constructorArguments.length;++i){const o=t.constructorArguments[i];void 0!==o&&o.kind!==A.unknown||n.push(`  - Missing or incomplete metadata for type "${e.name}" at constructor argument with index ${i.toString()}.\nEvery constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`)}for(const[i,o]of t.properties)o.kind===A.unknown&&n.push(`  - Missing or incomplete metadata for type "${e.name}" at property "${i.toString()}".\nThis property must be decorated either with @inject or @multiInject decorator.`);if(0===n.length)throw new T(S.unknown,`Unexpected class metadata for type "${e.name}" with uncompletion traces.\nThis might be caused by one of the following reasons:\n\n1. A third party library is targeting inversify reflection metadata.\n2. A bug is causing the issue. Consider submiting an issue to fix it.`);throw new T(S.missingInjectionDecorator,`Invalid class metadata at type ${e.name}:\n\n${n.join("\n\n")}`)}(t,n)}function x(){return 0}function R(e){return t=>{void 0!==t&&t.kind===A.unknown&&n(e,b,x,(e=>e-1))}}function B(e,t){return(...n)=>i=>{if(void 0===i)return e(...n);if(i.kind===C.unmanaged)throw new T(S.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");return t(i,...n)}}function k(e){if(e.kind!==A.unknown&&!0!==e.isFromTypescriptParamType)throw new T(S.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found")}!function(e){e[e.injectionDecoratorConflict=0]="injectionDecoratorConflict",e[e.missingInjectionDecorator=1]="missingInjectionDecorator",e[e.planning=2]="planning",e[e.resolution=3]="resolution",e[e.unknown=4]="unknown"}(S||(S={})),function(e){e[e.unknown=32]="unknown"}(A||(A={})),function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection",e[e.unmanaged=2]="unmanaged"}(C||(C={}));const P=B((function(e,t){return{kind:e,name:void 0,optional:!1,tags:new Map,value:t}}),(function(e,t,n){return k(e),{...e,kind:t,value:n}}));function D(e,t){return n=>{const i=n.properties.get(t);return n.properties.set(t,e(i)),n}}var F;function O(e,t,n,i){if(T.isErrorOfKind(i,S.injectionDecoratorConflict)){const o=function(e,t,n){if(void 0===n){if(void 0===t)throw new T(S.unknown,"Unexpected undefined property and index values");return{kind:F.property,property:t,targetClass:e.constructor}}return"number"==typeof n?{index:n,kind:F.parameter,targetClass:e}:{kind:F.method,method:t,targetClass:e}}(e,t,n);throw new T(S.injectionDecoratorConflict,`Unexpected injection error.\n\nCause:\n\n${i.message}\n\nDetails\n\n${function(e){switch(e.kind){case F.method:return`[class: "${e.targetClass.name}", method: "${e.method.toString()}"]`;case F.parameter:return`[class: "${e.targetClass.name}", index: "${e.index.toString()}"]`;case F.property:return`[class: "${e.targetClass.name}", property: "${e.property.toString()}"]`}}(o)}`,{cause:i})}throw i}function V(e,t){return(i,o,r)=>{try{void 0===r?function(e,t){const i=E(e,t);return(e,t)=>{n(e.constructor,I,w,D(i(e),t))}}(e,t)(i,o):"number"==typeof r?function(e,t){const i=E(e,t);return(e,t,o)=>{if(!function(e,t){return"function"==typeof e&&void 0===t}(e,t))throw new T(S.injectionDecoratorConflict,`Found an @inject decorator in a non constructor parameter.\nFound @inject decorator at method "${t?.toString()??""}" at class "${e.constructor.name}"`);n(e,I,w,function(e,t){return n=>{const i=n.constructorArguments[t];return n.constructorArguments[t]=e(i),n}}(i(e),o))}}(e,t)(i,o,r):function(e,t){const i=E(e,t);return(e,t,o)=>{if(!function(e){return void 0!==e.set}(o))throw new T(S.injectionDecoratorConflict,`Found an @inject decorator in a non setter property method.\nFound @inject decorator at method "${t.toString()}" at class "${e.constructor.name}"`);n(e.constructor,I,w,D(i(e),t))}}(e,t)(i,o,r)}catch(e){O(i,o,r,e)}}}function E(e,t){return n=>{const i=t(n);return t=>(i(t),e(t))}}function N(e){return V(P(C.singleInjection,e),R)}!function(e){e[e.method=0]="method",e[e.parameter=1]="parameter",e[e.property=2]="property"}(F||(F={}));const U="@inversifyjs/core/classIsInjectableFlagReflectKey";const K=[Array,BigInt,Boolean,Function,Number,Object,String];function q(t){const i=e(t,"design:paramtypes");void 0!==i&&n(t,I,w,function(e){return t=>(e.forEach(((e,n)=>{var i;void 0!==t.constructorArguments[n]||(i=e,K.includes(i))||(t.constructorArguments[n]=function(e){return{isFromTypescriptParamType:!0,kind:C.singleInjection,name:void 0,optional:!1,tags:new Map,value:e}}(e))})),t)}(i))}function z(i){return o=>{!function(n){if(void 0!==e(n,U))throw new T(S.injectionDecoratorConflict,`Cannot apply @injectable decorator multiple times at class "${n.name}"`);t(n,U,!0)}(o),q(o),void 0!==i&&n(o,I,w,(e=>({...e,scope:i})))}}function G(e,t,n){let i;return e.extendConstructorArguments??!0?(i=[...t.constructorArguments],n.constructorArguments.map(((e,t)=>{i[t]=e}))):i=n.constructorArguments,i}function _(e,t,n){let i;return i=e.extendProperties??!0?new Map(l(t.properties,n.properties)):n.properties,i}function X(e){return t=>{const i=$(e.type);n(t,I,w,function(e,t){const n=n=>({constructorArguments:G(e,t,n),lifecycle:n.lifecycle,properties:_(e,t,n),scope:n.scope});return n}(e,i))}}function H(e){return t=>{const n=i(t);if(void 0===n)throw new T(S.injectionDecoratorConflict,`Expected base type for type "${t.name}", none found.`);X({...e,type:n})(t)}}function J(e){return V(P(C.multipleInjection,e),R)}function L(e){return t=>{void 0===t&&n(e,b,x,(e=>e+1))}}function Q(e){return t=>{const n=t??{kind:A.unknown,name:void 0,optional:!1,tags:new Map};if(n.kind===C.unmanaged)throw new T(S.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return e(n)}}function W(e){const t=Q(function(e){return t=>{if(void 0!==t.name)throw new T(S.injectionDecoratorConflict,"Unexpected duplicated named decorator");return t.name=e,t}}(e));return V(t,L)}function Y(e){if(e.optional)throw new T(S.injectionDecoratorConflict,"Unexpected duplicated optional decorator");return e.optional=!0,e}function Z(){return V(Q(Y),L)}function ee(){return(e,t,i)=>{try{n(e.constructor,I,w,(o=t,e=>{if(void 0!==e.lifecycle.postConstructMethodName)throw new T(S.injectionDecoratorConflict,"Unexpected duplicated postConstruct decorator");return e.lifecycle.postConstructMethodName=o,e}))}catch(n){O(e,t,void 0,n)}var o}}function te(){return(e,t,i)=>{try{n(e.constructor,I,w,(o=t,e=>{if(void 0!==e.lifecycle.preDestroyMethodName)throw new T(S.injectionDecoratorConflict,"Unexpected duplicated preDestroy decorator");return e.lifecycle.preDestroyMethodName=o,e}))}catch(n){O(e,t,void 0,n)}var o}}function ne(e,t){const n=Q(function(e,t){return n=>{if(n.tags.has(e))throw new T(S.injectionDecoratorConflict,"Unexpected duplicated tag decorator with existing tag");return n.tags.set(e,t),n}}(e,t));return V(n,L)}function ie(){return{kind:C.unmanaged}}const oe=B(ie,(function(e){if(k(e),function(e){return void 0!==e.name||e.optional||e.tags.size>0}(e))throw new T(S.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return ie()}));function re(){return V(oe(),R)}var ae;!function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection"}(ae||(ae={}));class se{#p;constructor(e){this.#p=e}get name(){return this.#p.elem.name}get serviceIdentifier(){return this.#p.elem.serviceIdentifier}get tags(){return this.#p.elem.tags}getAncestor(){if(void 0!==this.#p.previous)return new se(this.#p.previous)}}class ce{last;constructor(e){this.last=e}concat(e){return new ce({elem:e,previous:this.last})}[Symbol.iterator](){let e=this.last;return{next:()=>{if(void 0===e)return{done:!0,value:void 0};const t=e.elem;return e=e.previous,{done:!1,value:t}}}}}function ue(e,t,n){const i=n?.customServiceIdentifier??t.serviceIdentifier,o=[...e.getBindings(i)??[]].filter((e=>e.isSatisfiedBy(t)));if(0===o.length&&void 0!==e.autobindOptions&&"function"==typeof i){const t=function(e,t){const n=$(t),i=n.scope??e.scope;return{cache:{isRight:!1,value:void 0},id:c(),implementationType:t,isSatisfiedBy:()=>!0,moduleId:void 0,onActivation:void 0,onDeactivation:void 0,scope:i,serviceIdentifier:t,type:d.Instance}}(e.autobindOptions,i);e.setBinding(t),o.push(t)}return o}function de(e){return void 0!==e.redirections}function le(e,t,n,i){let r,a;de(n)?(r=n.binding.targetServiceIdentifier,a=n.binding.serviceIdentifier):(r=n.serviceIdentifier,a=n.parent?.binding.serviceIdentifier),Array.isArray(e)?function(e,t,n,i,r){if(0!==e.length){const t=`Ambiguous bindings found for service: "${o(n)}".\n\nRegistered bindings:\n\n${e.map((e=>function(e){switch(e.type){case d.Instance:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}", implementationType: "${e.implementationType.name}" ]`;case d.ServiceRedirection:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", redirection: "${o(e.targetServiceIdentifier)}" ]`;default:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}" ]`}}(e.binding))).join("\n")}\n\nTrying to resolve bindings for "${fe(n,i)}".\n\n${ge(r)}`;throw new T(S.planning,t)}t||pe(n,i,r)}(e,t,r,a,i):function(e,t,n,i,o){if(void 0!==e||t)return;pe(n,i,o)}(e,t,r,a,i)}function pe(e,t,n){const i=`No bindings found for service: "${o(e)}".\n\nTrying to resolve bindings for "${fe(e,t)}".\n\n${ge(n)}`;throw new T(S.planning,i)}function fe(e,t){return void 0===t?`${o(e)} (Root service)`:o(t)}function ge(e){const t=0===e.tags.size?"":`\n- tags:\n  - ${[...e.tags.keys()].map((e=>e.toString())).join("\n  - ")}`;return`Binding constraints:\n- service identifier: ${o(e.serviceIdentifier)}\n- name: ${e.name?.toString()??"-"}${t}`}function me(e,t,n){if(1!==e.redirections.length)le(e.redirections,t,e,n);else{const[i]=e.redirections;de(i)&&me(i,t,n)}}function he(e,t,n){if(Array.isArray(e.bindings)&&1===e.bindings.length){const[i]=e.bindings;de(i)&&me(i,t,n)}else le(e.bindings,t,e,n)}function ve(e,t){if(function(e){return e instanceof Error&&(e instanceof RangeError&&/stack space|call stack|too much recursion/i.test(e.message)||"InternalError"===e.name&&/too much recursion/.test(e.message))}(t)){const n=function(e){const t=[...e];if(0===t.length)return"(No dependency trace)";return t.map(o).join(" -> ")}(function(e){const t=new Set;for(const n of e.servicesBranch){if(t.has(n))return[...t,n];t.add(n)}return[...t]}(e));throw new T(S.planning,`Circular dependency found: ${n}`,{cause:t})}throw t}function ye(e){try{const t=new Map;void 0!==e.rootConstraints.tag&&t.set(e.rootConstraints.tag.key,e.rootConstraints.tag.value);const n=new ce({elem:{name:e.rootConstraints.name,serviceIdentifier:e.rootConstraints.serviceIdentifier,tags:t},previous:void 0}),i=new se(n.last),o=ue(e,i),r=[],a={bindings:r,parent:void 0,serviceIdentifier:e.rootConstraints.serviceIdentifier};if(r.push(...je(e,n,o,a)),!e.rootConstraints.isMultiple){he(a,e.rootConstraints.isOptional??!1,i);const[t]=r;a.bindings=t}return{tree:{root:a}}}catch(t){ve(e,t)}}function Me(e,t,n,i){const o={binding:t,classMetadata:e.getClassMetadata(t.implementationType),constructorParams:[],parent:i,propertyParams:new Map};return Se({autobindOptions:e.autobindOptions,getBindings:e.getBindings,getClassMetadata:e.getClassMetadata,node:o,servicesBranch:e.servicesBranch,setBinding:e.setBinding},n)}function Ie(e,t,n){if(n.kind===C.unmanaged)return;const i=r.is(n.value)?n.value.unwrap():n.value,o=t.concat({name:n.name,serviceIdentifier:i,tags:n.tags}),a=new se(o.last),s=ue(e,a),c=[],u={bindings:c,parent:e.node,serviceIdentifier:i};if(c.push(...je(e,o,s,u)),n.kind===C.singleInjection){he(u,n.optional,a);const[e]=c;u.bindings=e}return u}function we(e,t,n){const i=r.is(n.value)?n.value.unwrap():n.value,o=t.concat({name:n.name,serviceIdentifier:i,tags:n.tags}),a=new se(o.last),s=ue(e,a),c=[],u={bindings:c,parent:e.node,serviceIdentifier:i};if(c.push(...je(e,o,s,u)),n.kind===ae.singleInjection){he(u,n.optional,a);const[e]=c;u.bindings=e}return u}function be(e,t,n,i){const o={binding:t,params:[],parent:i};return Se({autobindOptions:e.autobindOptions,getBindings:e.getBindings,getClassMetadata:e.getClassMetadata,node:o,servicesBranch:e.servicesBranch,setBinding:e.setBinding},n)}function je(e,t,n,i){const o=de(i)?i.binding.targetServiceIdentifier:i.serviceIdentifier;e.servicesBranch.push(o);const r=[];for(const o of n)switch(o.type){case d.Instance:r.push(Me(e,o,t,i));break;case d.ResolvedValue:r.push(be(e,o,t,i));break;case d.ServiceRedirection:{const n=Te(e,t,o,i);r.push(n);break}default:r.push({binding:o,parent:i})}return e.servicesBranch.pop(),r}function Te(e,t,n,i){const o={binding:n,parent:i,redirections:[]},r=ue(e,new se(t.last),{customServiceIdentifier:n.targetServiceIdentifier});return o.redirections.push(...je(e,t,r,o)),o}function Se(e,t){return e.node.binding.type===d.Instance?function(e,t,n){const i=t.classMetadata;for(const[o,r]of i.constructorArguments.entries())t.constructorParams[o]=Ie(e,n,r);for(const[o,r]of i.properties){const i=Ie(e,n,r);void 0!==i&&t.propertyParams.set(o,i)}return e.node}(e,e.node,t):function(e,t,n){const i=t.binding.metadata;for(const[o,r]of i.arguments.entries())t.params[o]=we(e,n,r);return e.node}(e,e.node,t)}var Ae;!function(e){e[e.singleMandatory=0]="singleMandatory",e[e.singleOptional=1]="singleOptional",e[e.multipleMandatory=2]="multipleMandatory",e[e.multipleOptional=3]="multipleOptional",e[e.length=4]="length"}(Ae||(Ae={}));class Ce{#f;#g;#m;#h;#v;constructor(){this.#f=this.#y(),this.#g=this.#y(),this.#h=this.#y(),this.#m=this.#y(),this.#v=[]}clearCache(){for(const e of this.#M())e.clear();for(const e of this.#v)e.clearCache()}get(e){return void 0===e.name?void 0===e.tag?this.#I(this.#f,e).get(e.serviceIdentifier):this.#I(this.#m,e).get(e.serviceIdentifier)?.get(e.tag.key)?.get(e.tag.value):void 0===e.tag?this.#I(this.#g,e).get(e.serviceIdentifier)?.get(e.name):this.#I(this.#h,e).get(e.serviceIdentifier)?.get(e.name)?.get(e.tag.key)?.get(e.tag.value)}set(e,t){void 0===e.name?void 0===e.tag?this.#I(this.#f,e).set(e.serviceIdentifier,t):this.#w(this.#w(this.#I(this.#m,e),e.serviceIdentifier),e.tag.key).set(e.tag.value,t):void 0===e.tag?this.#w(this.#I(this.#g,e),e.serviceIdentifier).set(e.name,t):this.#w(this.#w(this.#w(this.#I(this.#h,e),e.serviceIdentifier),e.name),e.tag.key).set(e.tag.value,t)}subscribe(e){this.#v.push(e)}#y(){const e=new Array(Ae.length);for(let t=0;t<e.length;++t)e[t]=new Map;return e}#w(e,t){let n=e.get(t);return void 0===n&&(n=new Map,e.set(t,n)),n}#I(e,t){return e[this.#b(t)]}#M(){return[...this.#f,...this.#g,...this.#h,...this.#m]}#b(e){return e.isMultiple?!0===e.optional?Ae.multipleOptional:Ae.multipleMandatory:!0===e.optional?Ae.singleOptional:Ae.singleMandatory}}function $e(e,t){return a(t)?(e.cache={isRight:!0,value:t},t.then((t=>xe(e,t)))):xe(e,t)}function xe(e,t){return e.cache={isRight:!0,value:t},t}function Re(e,t,n){const i=e.getActivations(t);return void 0===i?n:a(n)?Be(e,n,i[Symbol.iterator]()):function(e,t,n){let i=t,o=n.next();for(;!0!==o.done;){const t=o.value(e.context,i);if(a(t))return Be(e,t,n);i=t,o=n.next()}return i}(e,n,i[Symbol.iterator]())}async function Be(e,t,n){let i=await t,o=n.next();for(;!0!==o.done;)i=await o.value(e.context,i),o=n.next();return i}function ke(e,t,n){let i=n;if(void 0!==t.onActivation){const n=t.onActivation;i=a(i)?i.then((t=>n(e.context,t))):n(e.context,i)}return Re(e,t.serviceIdentifier,i)}function Pe(e){return(t,n)=>{if(n.cache.isRight)return n.cache.value;return $e(n,ke(t,n,e(t,n)))}}const De=Pe((function(e,t){return t.value}));function Fe(e){return e}function Oe(e,t){return(n,i)=>{const o=e(i);switch(o.scope){case u.Singleton:if(o.cache.isRight)return o.cache.value;return $e(o,ke(n,o,t(n,i)));case u.Request:{if(n.requestScopeCache.has(o.id))return n.requestScopeCache.get(o.id);const e=ke(n,o,t(n,i));return n.requestScopeCache.set(o.id,e),e}case u.Transient:return ke(n,o,t(n,i))}}}const Ve=(e=>Oe(Fe,e))((function(e,t){return t.value(e.context)}));const Ee=Pe((function(e,t){return t.factory(e.context)}));function Ne(e,t,n){const i=function(e,t,n){if(void 0===n)return;if(!(n in e))throw new T(S.resolution,`Expecting a "${n.toString()}" property when resolving "${t.implementationType.name}" class @postConstruct decorated method, none found.`);if("function"!=typeof e[n])throw new T(S.resolution,`Expecting a "${n.toString()}" method when resolving "${t.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);{let i;try{i=e[n]()}catch(e){throw new T(S.resolution,`Unexpected error found when calling "${n.toString()}" @postConstruct decorated method on class "${t.implementationType.name}"`,{cause:e})}if(a(i))return async function(e,t,n){try{await n}catch(n){throw new T(S.resolution,`Unexpected error found when calling "${t.toString()}" @postConstruct decorated method on class "${e.implementationType.name}"`,{cause:n})}}(t,n,i)}}(e,t,n);return a(i)?i.then((()=>e)):e}function Ue(e){return(t,n,i)=>{const o=new i.binding.implementationType(...t),r=e(n,o,i);return a(r)?r.then((()=>Ne(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName))):Ne(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName)}}const Ke=Pe((function(e,t){return t.provider(e.context)}));function qe(e){return e.binding}function ze(e){return e.binding}const Ge=function(e){return(t,n,i)=>{const o=[];for(const[r,s]of i.propertyParams){const c=i.classMetadata.properties.get(r);if(void 0===c)throw new T(S.resolution,`Expecting metadata at property "${r.toString()}", none found`);c.kind!==C.unmanaged&&void 0!==s.bindings&&(n[r]=e(t,s),a(n[r])&&o.push((async()=>{n[r]=await n[r]})()))}if(o.length>0)return Promise.all(o).then((()=>{}))}}(Ye),_e=function(e){return function t(n,i){const o=[];for(const r of i.redirections)de(r)?o.push(...t(n,r)):o.push(e(n,r));return o}}(We),Xe=function(e,t,n){return(i,o)=>{const r=e(i,o);return a(r)?t(r,i,o):n(r,i,o)}}(function(e){return(t,n)=>{const i=[];for(const o of n.constructorParams)void 0===o?i.push(void 0):i.push(e(t,o));return i.some(a)?Promise.all(i):i}}(Ye),function(e){return async(t,n,i)=>{const o=await t;return e(o,n,i)}}(Ue(Ge)),Ue(Ge)),He=function(e){return(t,n)=>{const i=e(t,n);return a(i)?i.then((e=>n.binding.factory(...e))):n.binding.factory(...i)}}(function(e){return(t,n)=>{const i=[];for(const o of n.params)i.push(e(t,o));return i.some(a)?Promise.all(i):i}}(Ye)),Je=(e=>Oe(qe,e))(Xe),Le=(e=>Oe(ze,e))(He);function Qe(e){return Ye(e,e.planResult.tree.root)}function We(e,t){switch(t.binding.type){case d.ConstantValue:return De(e,t.binding);case d.DynamicValue:return Ve(e,t.binding);case d.Factory:return Ee(e,t.binding);case d.Instance:return Je(e,t);case d.Provider:return Ke(e,t.binding);case d.ResolvedValue:return Le(e,t)}}function Ye(e,t){if(void 0!==t.bindings)return Array.isArray(t.bindings)?function(e,t){const n=[];for(const i of t)de(i)?n.push(..._e(e,i)):n.push(We(e,i));if(n.some(a))return Promise.all(n);return n}(e,t.bindings):function(e,t){if(de(t)){const n=_e(e,t);if(1===n.length)return n[0];throw new T(S.resolution,"Unexpected multiple resolved values on single injection")}return We(e,t)}(e,t.bindings)}function Ze(e){return void 0!==e.scope}function et(e,t){if(void 0!==e.lifecycle.preDestroyMethodName&&"function"==typeof t[e.lifecycle.preDestroyMethodName])return t[e.lifecycle.preDestroyMethodName]()}function tt(e,t,n){const i=e.getDeactivations(t);if(void 0!==i)return a(n)?nt(n,i[Symbol.iterator]()):function(e,t){let n=t.next();for(;!0!==n.done;){const i=n.value(e);if(a(i))return nt(e,t);n=t.next()}}(n,i[Symbol.iterator]())}async function nt(e,t){const n=await e;let i=t.next();for(;!0!==i.done;)await i.value(n),i=t.next()}function it(e,t){const n=function(e,t){if(t.type===d.Instance){const n=e.getClassMetadata(t.implementationType),i=t.cache.value;return a(i)?i.then((e=>et(n,e))):et(n,i)}}(e,t);return void 0===n?ot(e,t):n.then((()=>ot(e,t)))}function ot(e,t){const n=t.cache;return a(n.value)?n.value.then((n=>rt(e,t,n))):rt(e,t,n.value)}function rt(e,t,n){let i;if(void 0!==t.onDeactivation){i=(0,t.onDeactivation)(n)}return void 0===i?tt(e,t.serviceIdentifier,n):i.then((()=>tt(e,t.serviceIdentifier,n)))}function at(e,t){if(void 0===t)return;const n=function(e){const t=[];for(const n of e)Ze(n)&&n.scope===u.Singleton&&n.cache.isRight&&t.push(n);return t}(t),i=[];for(const t of n){const n=it(e,t);void 0!==n&&i.push(n)}return i.length>0?Promise.all(i).then((()=>{})):void 0}function st(e,t){const n=e.getBindingsFromModule(t);return at(e,n)}function ct(e,t){const n=e.getBindings(t);return at(e,n)}export{h as ActivationsService,v as BindingService,C as ClassElementMetadataKind,y as DeactivationsService,Ce as PlanResultCacheService,ae as ResolvedValueElementMetadataKind,u as bindingScopeValues,d as bindingTypeValues,M as decorate,c as getBindingId,$ as getClassMetadata,N as inject,H as injectFromBase,z as injectable,J as multiInject,W as named,Z as optional,ye as plan,ee as postConstruct,te as preDestroy,Qe as resolve,at as resolveBindingsDeactivations,st as resolveModuleDeactivations,ct as resolveServiceDeactivations,ne as tagged,re as unmanaged};
//# sourceMappingURL=index.js.map
